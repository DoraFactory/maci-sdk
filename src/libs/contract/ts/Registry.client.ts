/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
	CosmWasmClient,
	SigningCosmWasmClient,
	ExecuteResult,
} from '@cosmjs/cosmwasm-stargate';
import { Coin, StdFee } from '@cosmjs/amino';
import {
	Addr,
	InstantiateMsg,
	ExecuteMsg,
	Uint256,
	Timestamp,
	Uint64,
	PubKey,
	RoundInfo,
	VotingTime,
	Whitelist,
	WhitelistConfig,
	ValidatorSet,
	QueryMsg,
	AdminResponse,
	String,
	Boolean,
} from './Registry.types';
export interface RegistryReadOnlyInterface {
	contractAddress: string;
	admin: () => Promise<AdminResponse>;
	operator: () => Promise<Addr>;
	isMaciOperator: ({ address }: { address: Addr }) => Promise<Boolean>;
	isValidator: ({ address }: { address: Addr }) => Promise<Boolean>;
	getValidators: () => Promise<ValidatorSet>;
	getValidatorOperator: ({ address }: { address: Addr }) => Promise<Addr>;
	getMaciOperatorPubkey: ({ address }: { address: Addr }) => Promise<PubKey>;
	getMaciOperatorIdentity: ({
		address,
	}: {
		address: Addr;
	}) => Promise<String>;
}
export class RegistryQueryClient implements RegistryReadOnlyInterface {
	client: CosmWasmClient;
	contractAddress: string;
	constructor(client: CosmWasmClient, contractAddress: string) {
		this.client = client;
		this.contractAddress = contractAddress;
		this.admin = this.admin.bind(this);
		this.operator = this.operator.bind(this);
		this.isMaciOperator = this.isMaciOperator.bind(this);
		this.isValidator = this.isValidator.bind(this);
		this.getValidators = this.getValidators.bind(this);
		this.getValidatorOperator = this.getValidatorOperator.bind(this);
		this.getMaciOperatorPubkey = this.getMaciOperatorPubkey.bind(this);
		this.getMaciOperatorIdentity = this.getMaciOperatorIdentity.bind(this);
	}
	admin = async (): Promise<AdminResponse> => {
		return this.client.queryContractSmart(this.contractAddress, {
			admin: {},
		});
	};
	operator = async (): Promise<Addr> => {
		return this.client.queryContractSmart(this.contractAddress, {
			operator: {},
		});
	};
	isMaciOperator = async ({
		address,
	}: {
		address: Addr;
	}): Promise<Boolean> => {
		return this.client.queryContractSmart(this.contractAddress, {
			is_maci_operator: {
				address,
			},
		});
	};
	isValidator = async ({ address }: { address: Addr }): Promise<Boolean> => {
		return this.client.queryContractSmart(this.contractAddress, {
			is_validator: {
				address,
			},
		});
	};
	getValidators = async (): Promise<ValidatorSet> => {
		return this.client.queryContractSmart(this.contractAddress, {
			get_validators: {},
		});
	};
	getValidatorOperator = async ({
		address,
	}: {
		address: Addr;
	}): Promise<Addr> => {
		return this.client.queryContractSmart(this.contractAddress, {
			get_validator_operator: {
				address,
			},
		});
	};
	getMaciOperatorPubkey = async ({
		address,
	}: {
		address: Addr;
	}): Promise<PubKey> => {
		return this.client.queryContractSmart(this.contractAddress, {
			get_maci_operator_pubkey: {
				address,
			},
		});
	};
	getMaciOperatorIdentity = async ({
		address,
	}: {
		address: Addr;
	}): Promise<String> => {
		return this.client.queryContractSmart(this.contractAddress, {
			get_maci_operator_identity: {
				address,
			},
		});
	};
}
export interface RegistryInterface extends RegistryReadOnlyInterface {
	contractAddress: string;
	sender: string;
	setMaciOperator: (
		{
			operator,
		}: {
			operator: Addr;
		},
		fee?: number | StdFee | 'auto',
		memo?: string,
		_funds?: Coin[]
	) => Promise<ExecuteResult>;
	setMaciOperatorPubkey: (
		{
			pubkey,
		}: {
			pubkey: PubKey;
		},
		fee?: number | StdFee | 'auto',
		memo?: string,
		_funds?: Coin[]
	) => Promise<ExecuteResult>;
	setMaciOperatorIdentity: (
		{
			identity,
		}: {
			identity: string;
		},
		fee?: number | StdFee | 'auto',
		memo?: string,
		_funds?: Coin[]
	) => Promise<ExecuteResult>;
	createRound: (
		{
			certificationSystem,
			circuitType,
			maxOption,
			maxVoter,
			operator,
			preDeactivateRoot,
			roundInfo,
			voiceCreditAmount,
			votingTime,
			whitelist,
		}: {
			certificationSystem: Uint256;
			circuitType: Uint256;
			maxOption: Uint256;
			maxVoter: Uint256;
			operator: Addr;
			preDeactivateRoot: Uint256;
			roundInfo: RoundInfo;
			voiceCreditAmount: Uint256;
			votingTime: VotingTime;
			whitelist?: Whitelist;
		},
		fee?: number | StdFee | 'auto',
		memo?: string,
		_funds?: Coin[]
	) => Promise<ExecuteResult>;
	setValidators: (
		{
			addresses,
		}: {
			addresses: ValidatorSet;
		},
		fee?: number | StdFee | 'auto',
		memo?: string,
		_funds?: Coin[]
	) => Promise<ExecuteResult>;
	removeValidator: (
		{
			address,
		}: {
			address: Addr;
		},
		fee?: number | StdFee | 'auto',
		memo?: string,
		_funds?: Coin[]
	) => Promise<ExecuteResult>;
	updateAmaciCodeId: (
		{
			amaciCodeId,
		}: {
			amaciCodeId: number;
		},
		fee?: number | StdFee | 'auto',
		memo?: string,
		_funds?: Coin[]
	) => Promise<ExecuteResult>;
	changeOperator: (
		{
			address,
		}: {
			address: Addr;
		},
		fee?: number | StdFee | 'auto',
		memo?: string,
		_funds?: Coin[]
	) => Promise<ExecuteResult>;
}
export class RegistryClient
	extends RegistryQueryClient
	implements RegistryInterface
{
	client: SigningCosmWasmClient;
	sender: string;
	contractAddress: string;
	constructor(
		client: SigningCosmWasmClient,
		sender: string,
		contractAddress: string
	) {
		super(client, contractAddress);
		this.client = client;
		this.sender = sender;
		this.contractAddress = contractAddress;
		this.setMaciOperator = this.setMaciOperator.bind(this);
		this.setMaciOperatorPubkey = this.setMaciOperatorPubkey.bind(this);
		this.setMaciOperatorIdentity = this.setMaciOperatorIdentity.bind(this);
		this.createRound = this.createRound.bind(this);
		this.setValidators = this.setValidators.bind(this);
		this.removeValidator = this.removeValidator.bind(this);
		this.updateAmaciCodeId = this.updateAmaciCodeId.bind(this);
		this.changeOperator = this.changeOperator.bind(this);
	}
	setMaciOperator = async (
		{
			operator,
		}: {
			operator: Addr;
		},
		fee: number | StdFee | 'auto' = 'auto',
		memo?: string,
		_funds?: Coin[]
	): Promise<ExecuteResult> => {
		return await this.client.execute(
			this.sender,
			this.contractAddress,
			{
				set_maci_operator: {
					operator,
				},
			},
			fee,
			memo,
			_funds
		);
	};
	setMaciOperatorPubkey = async (
		{
			pubkey,
		}: {
			pubkey: PubKey;
		},
		fee: number | StdFee | 'auto' = 'auto',
		memo?: string,
		_funds?: Coin[]
	): Promise<ExecuteResult> => {
		return await this.client.execute(
			this.sender,
			this.contractAddress,
			{
				set_maci_operator_pubkey: {
					pubkey,
				},
			},
			fee,
			memo,
			_funds
		);
	};
	setMaciOperatorIdentity = async (
		{
			identity,
		}: {
			identity: string;
		},
		fee: number | StdFee | 'auto' = 'auto',
		memo?: string,
		_funds?: Coin[]
	): Promise<ExecuteResult> => {
		return await this.client.execute(
			this.sender,
			this.contractAddress,
			{
				set_maci_operator_identity: {
					identity,
				},
			},
			fee,
			memo,
			_funds
		);
	};
	createRound = async (
		{
			certificationSystem,
			circuitType,
			maxOption,
			maxVoter,
			operator,
			preDeactivateRoot,
			roundInfo,
			voiceCreditAmount,
			votingTime,
			whitelist,
		}: {
			certificationSystem: Uint256;
			circuitType: Uint256;
			maxOption: Uint256;
			maxVoter: Uint256;
			operator: Addr;
			preDeactivateRoot: Uint256;
			roundInfo: RoundInfo;
			voiceCreditAmount: Uint256;
			votingTime: VotingTime;
			whitelist?: Whitelist;
		},
		fee: number | StdFee | 'auto' = 'auto',
		memo?: string,
		_funds?: Coin[]
	): Promise<ExecuteResult> => {
		return await this.client.execute(
			this.sender,
			this.contractAddress,
			{
				create_round: {
					certification_system: certificationSystem,
					circuit_type: circuitType,
					max_option: maxOption,
					max_voter: maxVoter,
					operator,
					pre_deactivate_root: preDeactivateRoot,
					round_info: roundInfo,
					voice_credit_amount: voiceCreditAmount,
					voting_time: votingTime,
					whitelist,
				},
			},
			fee,
			memo,
			_funds
		);
	};
	setValidators = async (
		{
			addresses,
		}: {
			addresses: ValidatorSet;
		},
		fee: number | StdFee | 'auto' = 'auto',
		memo?: string,
		_funds?: Coin[]
	): Promise<ExecuteResult> => {
		return await this.client.execute(
			this.sender,
			this.contractAddress,
			{
				set_validators: {
					addresses,
				},
			},
			fee,
			memo,
			_funds
		);
	};
	removeValidator = async (
		{
			address,
		}: {
			address: Addr;
		},
		fee: number | StdFee | 'auto' = 'auto',
		memo?: string,
		_funds?: Coin[]
	): Promise<ExecuteResult> => {
		return await this.client.execute(
			this.sender,
			this.contractAddress,
			{
				remove_validator: {
					address,
				},
			},
			fee,
			memo,
			_funds
		);
	};
	updateAmaciCodeId = async (
		{
			amaciCodeId,
		}: {
			amaciCodeId: number;
		},
		fee: number | StdFee | 'auto' = 'auto',
		memo?: string,
		_funds?: Coin[]
	): Promise<ExecuteResult> => {
		return await this.client.execute(
			this.sender,
			this.contractAddress,
			{
				update_amaci_code_id: {
					amaci_code_id: amaciCodeId,
				},
			},
			fee,
			memo,
			_funds
		);
	};
	changeOperator = async (
		{
			address,
		}: {
			address: Addr;
		},
		fee: number | StdFee | 'auto' = 'auto',
		memo?: string,
		_funds?: Coin[]
	): Promise<ExecuteResult> => {
		return await this.client.execute(
			this.sender,
			this.contractAddress,
			{
				change_operator: {
					address,
				},
			},
			fee,
			memo,
			_funds
		);
	};
}
