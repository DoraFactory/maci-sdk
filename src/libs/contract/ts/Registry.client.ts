/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  CosmWasmClient,
  SigningCosmWasmClient,
  ExecuteResult,
} from '@cosmjs/cosmwasm-stargate';
import { Coin, StdFee } from '@cosmjs/amino';
import {
  Addr,
  InstantiateMsg,
  ExecuteMsg,
  Uint256,
  Timestamp,
  Uint64,
  PubKey,
  RoundInfo,
  VotingTime,
  Whitelist,
  WhitelistConfig,
  ValidatorSet,
  QueryMsg,
  AdminResponse,
  String,
  Boolean,
} from './Registry.types';
export interface RegistryReadOnlyInterface {
  contractAddress: string;
  admin: () => Promise<AdminResponse>;
  operator: () => Promise<Addr>;
  isMaciOperator: ({ address }: { address: Addr }) => Promise<Boolean>;
  isValidator: ({ address }: { address: Addr }) => Promise<Boolean>;
  getValidators: () => Promise<ValidatorSet>;
  getValidatorOperator: ({ address }: { address: Addr }) => Promise<Addr>;
  getMaciOperatorPubkey: ({ address }: { address: Addr }) => Promise<PubKey>;
  getMaciOperatorIdentity: ({ address }: { address: Addr }) => Promise<String>;
}
export class RegistryQueryClient implements RegistryReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.admin = this.admin.bind(this);
    this.operator = this.operator.bind(this);
    this.isMaciOperator = this.isMaciOperator.bind(this);
    this.isValidator = this.isValidator.bind(this);
    this.getValidators = this.getValidators.bind(this);
    this.getValidatorOperator = this.getValidatorOperator.bind(this);
    this.getMaciOperatorPubkey = this.getMaciOperatorPubkey.bind(this);
    this.getMaciOperatorIdentity = this.getMaciOperatorIdentity.bind(this);
  }
  admin = async (): Promise<AdminResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {},
    });
  };
  operator = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      operator: {},
    });
  };
  isMaciOperator = async ({ address }: { address: Addr }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_maci_operator: {
        address,
      },
    });
  };
  isValidator = async ({ address }: { address: Addr }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_validator: {
        address,
      },
    });
  };
  getValidators = async (): Promise<ValidatorSet> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_validators: {},
    });
  };
  getValidatorOperator = async ({
    address,
  }: {
    address: Addr;
  }): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_validator_operator: {
        address,
      },
    });
  };
  getMaciOperatorPubkey = async ({
    address,
  }: {
    address: Addr;
  }): Promise<PubKey> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_maci_operator_pubkey: {
        address,
      },
    });
  };
  getMaciOperatorIdentity = async ({
    address,
  }: {
    address: Addr;
  }): Promise<String> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_maci_operator_identity: {
        address,
      },
    });
  };
}
export interface RegistryInterface extends RegistryReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setMaciOperator: (
    {
      operator,
    }: {
      operator: Addr;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  setMaciOperatorPubkey: (
    {
      pubkey,
    }: {
      pubkey: PubKey;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  setMaciOperatorIdentity: (
    {
      identity,
    }: {
      identity: string;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  createRound: (
    {
      certificationSystem,
      circuitType,
      maxOption,
      maxVoter,
      operator,
      preDeactivateRoot,
      roundInfo,
      voiceCreditAmount,
      votingTime,
      whitelist,
    }: {
      certificationSystem: Uint256;
      circuitType: Uint256;
      maxOption: Uint256;
      maxVoter: Uint256;
      operator: Addr;
      preDeactivateRoot: Uint256;
      roundInfo: RoundInfo;
      voiceCreditAmount: Uint256;
      votingTime: VotingTime;
      whitelist?: Whitelist;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  setValidators: (
    {
      addresses,
    }: {
      addresses: ValidatorSet;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  removeValidator: (
    {
      address,
    }: {
      address: Addr;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  updateAmaciCodeId: (
    {
      amaciCodeId,
    }: {
      amaciCodeId: number;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
  changeOperator: (
    {
      address,
    }: {
      address: Addr;
    },
    fee?: number | StdFee | 'auto',
    memo?: string,
    _funds?: Coin[]
  ) => Promise<ExecuteResult>;
}
export class RegistryClient
  extends RegistryQueryClient
  implements RegistryInterface
{
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(
    client: SigningCosmWasmClient,
    sender: string,
    contractAddress: string
  ) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setMaciOperator = this.setMaciOperator.bind(this);
    this.setMaciOperatorPubkey = this.setMaciOperatorPubkey.bind(this);
    this.setMaciOperatorIdentity = this.setMaciOperatorIdentity.bind(this);
    this.createRound = this.createRound.bind(this);
    this.setValidators = this.setValidators.bind(this);
    this.removeValidator = this.removeValidator.bind(this);
    this.updateAmaciCodeId = this.updateAmaciCodeId.bind(this);
    this.changeOperator = this.changeOperator.bind(this);
  }
  setMaciOperator = async (
    {
      operator,
    }: {
      operator: Addr;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_maci_operator: {
          operator,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  setMaciOperatorPubkey = async (
    {
      pubkey,
    }: {
      pubkey: PubKey;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_maci_operator_pubkey: {
          pubkey,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  setMaciOperatorIdentity = async (
    {
      identity,
    }: {
      identity: string;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_maci_operator_identity: {
          identity,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  createRound = async (
    {
      certificationSystem,
      circuitType,
      maxOption,
      maxVoter,
      operator,
      preDeactivateRoot,
      roundInfo,
      voiceCreditAmount,
      votingTime,
      whitelist,
    }: {
      certificationSystem: Uint256;
      circuitType: Uint256;
      maxOption: Uint256;
      maxVoter: Uint256;
      operator: Addr;
      preDeactivateRoot: Uint256;
      roundInfo: RoundInfo;
      voiceCreditAmount: Uint256;
      votingTime: VotingTime;
      whitelist?: Whitelist;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        create_round: {
          certification_system: certificationSystem,
          circuit_type: circuitType,
          max_option: maxOption,
          max_voter: maxVoter,
          operator,
          pre_deactivate_root: preDeactivateRoot,
          round_info: roundInfo,
          voice_credit_amount: voiceCreditAmount,
          voting_time: votingTime,
          whitelist,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  setValidators = async (
    {
      addresses,
    }: {
      addresses: ValidatorSet;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        set_validators: {
          addresses,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  removeValidator = async (
    {
      address,
    }: {
      address: Addr;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        remove_validator: {
          address,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  updateAmaciCodeId = async (
    {
      amaciCodeId,
    }: {
      amaciCodeId: number;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        update_amaci_code_id: {
          amaci_code_id: amaciCodeId,
        },
      },
      fee,
      memo,
      _funds
    );
  };
  changeOperator = async (
    {
      address,
    }: {
      address: Addr;
    },
    fee: number | StdFee | 'auto' = 'auto',
    memo?: string,
    _funds?: Coin[]
  ): Promise<ExecuteResult> => {
    return await this.client.execute(
      this.sender,
      this.contractAddress,
      {
        change_operator: {
          address,
        },
      },
      fee,
      memo,
      _funds
    );
  };
}
